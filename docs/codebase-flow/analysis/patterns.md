PATTERNS: 1.Module(Config,Utils,Storage,Sync:const Utils={generateId(){...},escapeHtml(){...}};Object.freeze(Utils);benefits:namespace,no instantiation,prevents mod,clear API;why:utils no state,single instance,perf no constructor);2.Constructor Injection(all classes:class TaskManager{constructor(app){this.app=app}};const tm=new TaskManager(appInstance);benefits:explicit deps,easy test(mocks),loose coupling,clear ownership;why:visible deps,supports testing,no global state);3.Composition(DoItTomorrowApp+modules:class DoItTomorrowApp{constructor(){this.taskManager=new TaskManager(this);this.renderer=new Renderer(this);...}};benefits:flexible,no deep inheritance,easy add/remove features,clear responsibilities;why:inheritance not needed,modules=independent features,easier understand+maintain);4.Debouncing(saveData,render:saveData(){clearTimeout(this.saveTimeout);this.saveTimeout=setTimeout(()=>Storage.save(this.data),Config.SAVE_DEBOUNCE_MS)};benefits:perf optimize,reduce unnecessary ops,batch rapid changes,better UX(less flicker);why:typing triggers many,localStorage writes expensive,DOM updates expensive,60fps goal);5.Event Delegation(task lists:document.getElementById('today-list').addEventListener('click',e=>{const taskItem=e.target.closest('.task-item');const taskId=taskItem?.dataset.taskId;...});benefits:fewer listeners,works dynamic elements,better perf,simpler cleanup;why:tasks add/remove freq,100s potential tasks,memory efficiency,simpler code);6.State Mgmt Centralized(app.data single source:class DoItTomorrowApp{constructor(){this.data={tasks[],lastUpdated:Date.now(),currentDate:Utils.getTodayISO(),totalCompleted:0}}};all modules access this.app.data;benefits:single source truth,predictable updates,easy debug(one place),simple persist;why:small app no complex state,localStorage needs single obj,clear ownership,no sync issues);7.Observer Implicit(save/render triggers:addTask(text,listName){taskManager.addTask(text,listName);this.saveData();this.render()};note:not formal(no subscribe/notify),follows concept;benefits:state changes→side effects,separation concerns,predictable flow;potential:implement formal Observer,reduce manual save/render calls);8.Factory Light(task creation:addTask(text,listName){const task={id:Utils.generateId(),text:Utils.escapeHtml(text),list:listName,completed:false,important:false,subtasks[],deadline:null,parentId:null};this.app.data.tasks.push(task);return task.id};benefits:consistent structure,defaults guaranteed,validation one place;why:tasks need consistent,defaults prevent undefined,easier add props);9.Strategy(export formats:exportToFile(){const data=Sync.compress(this.app.data);/*file strategy*/},exportToClipboard(){const data=Sync.compress(this.app.data);/*clipboard strategy*/},exportToQR(){const data=Sync.compress(this.app.data);/*QR strategy*/};benefits:same data/different outputs,easy add formats,shared compression;why:multiple export destinations,common prep,user choice);10.Command Implicit(user actions:addTask()/*Command:Create Task*/,toggleTask()/*Command:Toggle Complete*/,moveTask()/*Command:Move Lists*/,deleteTask()/*Command:Remove Task*/;benefits:clear action boundaries,could add undo/redo,logging/tracking possible;potential:formalize Command objs,implement undo/redo stack,add action history);11.Lazy Init(module init:init(){this.initTheme();this.updateCurrentDate();this.checkDateRollover();...this.render()};benefits:fast page load,setup only needed,clear init order;why:not everything immediate,some setup depends DOM ready,controlled sequence);12.Template(task element:createTaskElement(task,idx){const li=this.createContainer();this.addCheckbox(li,task);this.addText(li,task);this.addActions(li,task);if(task.subtasks.length)this.addSubtasks(li,task);return li};benefits:consistent structure,easy modify template,reusable subtasks;why:all tasks rendered similarly,subtasks same pattern,customization via data props);13.Null Object(default data:getDefaultData(){return{tasks[],lastUpdated:Date.now(),currentDate:Utils.getTodayISO(),totalCompleted:0,version:2}};benefits:no null checks,always valid,prevents undefined errors;why:simplifies code,reduces defensive programming,clear defaults);14.Facade(storage abstraction:const Storage={load(){/*hides:localStorage.getItem,JSON.parse,migration*/},save(data){/*hides:JSON.stringify,localStorage.setItem,error handling*/}};benefits:simple API for complex ops,hides localStorage details,easy swap backend;why:localStorage API low-level,migration complex,error handling repetitive);15.Adapter(sync compress/decompress:const Sync={compress(data){/*adapts internal→export*/},decompress(string){/*adapts export→internal*/}};benefits:isolates format changes,internal independent export,easy version formats;why:internal+export formats differ,support multiple import sources,format evolution);anti-patterns avoided:1.God Object(avoided:App could become,mitigation:delegates specialized modules),2.Tight Coupling(avoided:modules directly mod each other data,mitigation:app.data shared state+methods mutations),3.Copy-Paste(avoided:duplicated task ops,mitigation:TaskManager centralizes),4.Magic Numbers(avoided:hardcoded timing,mitigation:Config.js all constants),5.Callback Hell(avoided:deep callback nesting,mitigation:Promises+async/await),6.Global State Pollution(avoided:window-level vars,mitigation:Module pattern+single app instance);recommendations:1.Observer Formal(current:manual saveData/render,proposed:auto triggers data mutation via Proxy{set(target,property,value){target[property]=value;app.saveData();app.render();return true}},benefits:no manual calls,impossible forget,cleaner code;tradeoffs:more complex,harder debug,perf overhead),2.Command Formal(current:direct methods,proposed:Command objs+undo/redo via class AddTaskCommand{execute(){/*add*/}undo(){/*remove*/}}+const commandHistory[];benefits:undo/redo,command history,better testing;tradeoffs:more boilerplate,complexity increase,memory overhead),3.Repository(current:direct localStorage,proposed:abstract data access via class TaskRepository{getAll(){...}getById(id){...}save(task){...}delete(id){...}};benefits:easy swap backends(IndexedDB,server),better testing,clearer API;tradeoffs:added abstraction,more code,may be overkill);conclusion:effective use:Module(utils+constants),Dependency Injection(testability),Composition(flexibility),Debouncing(performance),Event Delegation(efficiency),Centralized State(simplicity);overall:good pattern usage for app size,patterns prioritize simplicity+maintainability over architectural purity;recommendation:current patterns appropriate,consider Observer formalization if app grows significantly